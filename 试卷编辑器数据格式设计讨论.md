# 试卷编辑器数据格式设计讨论

## 一、背景

我们需要从零搭建一个试卷编辑器，涉及以下题型：

### 听力题
1. 听力选择
2. 听力填空
3. 听力连线
4. 听力排序

### 口语题
- 多步骤录音提交（第1步 → 第2步 → ... → 第N步）

---

## 二、核心问题：数据存储格式选择

### 方案对比：JSON vs HTML(div)

| 维度 | JSON 结构化 | HTML/div 富文本 |
|------|------------|----------------|
| **数据与展示** | 分离 ✅ | 耦合 ❌ |
| **程序处理** | 易解析、易操作 ✅ | 需要 DOM 解析 ❌ |
| **跨平台适配** | 一套数据多端渲染 ✅ | 需要针对各端改样式 ❌ |
| **答案提取** | 直接读取字段 ✅ | 需解析 HTML 结构 ❌ |
| **评分逻辑** | 结构化比对 ✅ | 复杂且易出错 ❌ |
| **富文本支持** | 需额外处理 ⚠️ | 原生支持 ✅ |
| **第三方导入** | 需要转换 ⚠️ | 可直接使用 ✅ |
| **数据迁移** | 方便 ✅ | 困难 ❌ |
| **安全性** | 无 XSS 风险 ✅ | 有 XSS 风险 ⚠️ |
| **编辑器开发** | 需要构建 ⚠️ | 现成富文本编辑器多 ✅ |

---

## 三、现有系统数据分析（学科网示例）

### 3.1 原始数据结构

```json
{
  "id": "2361627607932928",
  "status": 1,
  "media": 1,
  "difficulty": 0.65,
  "stem": "<!-- HTML字符串，包含题干、音频、选项 -->",
  "answer": "<!-- HTML字符串，包含答案 -->",
  "explanation": "<!-- HTML字符串，包含解析 -->",
  "assigntime": 300
}
```

### 3.2 这是一种"混合模式"

- **外层**：JSON 结构（id、status、difficulty 等元数据）
- **内层**：stem/answer/explanation 字段存储 HTML 字符串

### 3.3 混合模式的问题

```
┌─────────────────────────────────────────────────────────────┐
│  问题1：答案提取困难                                          │
│  ─────────────────                                          │
│  answer: "<div>1. <span class='qml-an'>A</span>..."         │
│                                                              │
│  → 需要解析 HTML 才能知道第1题答案是 A                         │
│  → 如果 HTML 结构变化，解析逻辑就会失效                        │
└─────────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────────┐
│  问题2：交互逻辑复杂                                          │
│  ─────────────────                                          │
│  你的描述：                                                   │
│  "我解析出来在前面添加上选择图标，然后添加点击事件，              │
│   然后按照自己的样子进行设置提交之后正确样式"                    │
│                                                              │
│  → 需要手动解析 DOM，插入元素，绑定事件                        │
│  → 代码脆弱，维护困难                                         │
└─────────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────────┐
│  问题3：题目结构隐藏在 HTML 中                                 │
│  ─────────────────────────────                              │
│  从 stem 的 HTML 中可以看到：                                 │
│  - 主题干（带音频）                                           │
│  - 3个子题（class="qml-sq"）                                 │
│  - 每个子题有 A/B/C 选项                                      │
│                                                              │
│  → 这些结构信息被"埋"在 HTML 里                               │
│  → 程序无法直接知道"有几个子题""每题几个选项"                   │
└─────────────────────────────────────────────────────────────┘
```

---

## 四、推荐方案：纯 JSON 结构化存储

### 4.1 听力选择题示例

```json
{
  "id": "question_001",
  "type": "listening_choice",
  "version": "1.0",
  "metadata": {
    "difficulty": 0.65,
    "duration": 300,
    "source": "2024年中考模拟",
    "tags": ["交通事故", "新闻报道"]
  },
  "audio": {
    "url": "https://xxx.com/audio.mp3",
    "duration": 91,
    "transcript": "Here's the Morning News. A terrible traffic accident happened..."
  },
  "stem": {
    "text": "下面请听材料，并回答下列小题。",
    "richText": null
  },
  "subQuestions": [
    {
      "id": "sq_1",
      "order": 1,
      "stem": "When did the accident happen?",
      "options": [
        { "key": "A", "content": "In the morning." },
        { "key": "B", "content": "In the afternoon." },
        { "key": "C", "content": "In the evening." }
      ],
      "answer": "A",
      "explanation": "音频开头说 at about 6:30 this morning"
    },
    {
      "id": "sq_2",
      "order": 2,
      "stem": "Where did the accident happen?",
      "options": [
        { "key": "A", "content": "In Zhongshan Park." },
        { "key": "B", "content": "On Zhongshan Road." },
        { "key": "C", "content": "Near Zhongshan Park." }
      ],
      "answer": "C",
      "explanation": "at the corner near Zhongshan Park"
    },
    {
      "id": "sq_3",
      "order": 3,
      "stem": "How many people were hurt in the accident?",
      "options": [
        { "key": "A", "content": "Four." },
        { "key": "B", "content": "Five." },
        { "key": "C", "content": "Six." }
      ],
      "answer": "C",
      "explanation": "Five passengers + bus driver = 6 people"
    }
  ]
}
```

### 4.2 听力填空题示例

```json
{
  "id": "question_002",
  "type": "listening_fill",
  "audio": {
    "url": "https://xxx.com/audio2.mp3",
    "duration": 60
  },
  "stem": "Listen and fill in the blanks.",
  "content": {
    "template": "The meeting will be held on {{blank_1}} at {{blank_2}} o'clock.",
    "blanks": [
      {
        "id": "blank_1",
        "answer": ["Monday", "monday"],
        "acceptVariants": true,
        "hint": "星期"
      },
      {
        "id": "blank_2",
        "answer": ["9", "nine"],
        "acceptVariants": true,
        "hint": "时间"
      }
    ]
  }
}
```

### 4.3 听力连线题示例

```json
{
  "id": "question_003",
  "type": "listening_match",
  "audio": {
    "url": "https://xxx.com/audio3.mp3"
  },
  "stem": "听录音，将人物与他们的职业连线。",
  "leftItems": [
    { "id": "L1", "content": "Tom" },
    { "id": "L2", "content": "Mary" },
    { "id": "L3", "content": "Jack" }
  ],
  "rightItems": [
    { "id": "R1", "content": "Teacher" },
    { "id": "R2", "content": "Doctor" },
    { "id": "R3", "content": "Engineer" }
  ],
  "answers": [
    { "left": "L1", "right": "R2" },
    { "left": "L2", "right": "R1" },
    { "left": "L3", "right": "R3" }
  ]
}
```

### 4.4 听力排序题示例

```json
{
  "id": "question_004",
  "type": "listening_order",
  "audio": {
    "url": "https://xxx.com/audio4.mp3"
  },
  "stem": "听录音，将下列事件按发生顺序排列。",
  "items": [
    { "id": "item_A", "content": "He went to school." },
    { "id": "item_B", "content": "He had breakfast." },
    { "id": "item_C", "content": "He woke up." },
    { "id": "item_D", "content": "He took a shower." }
  ],
  "answer": ["item_C", "item_D", "item_B", "item_A"]
}
```

### 4.5 口语题示例（多步骤）

```json
{
  "id": "question_005",
  "type": "speaking_steps",
  "stem": "请根据提示完成以下口语任务",
  "totalSteps": 4,
  "steps": [
    {
      "step": 1,
      "instruction": "Listen to the question and prepare your answer.",
      "audio": {
        "url": "https://xxx.com/prompt1.mp3",
        "autoPlay": true
      },
      "prepareTime": 10,
      "recordTime": 0,
      "requiresRecording": false
    },
    {
      "step": 2,
      "instruction": "Now please answer the question.",
      "prepareTime": 0,
      "recordTime": 30,
      "requiresRecording": true,
      "scoringCriteria": {
        "pronunciation": 3,
        "fluency": 3,
        "content": 4
      }
    },
    {
      "step": 3,
      "instruction": "Read the following passage aloud.",
      "text": "The Great Wall is one of the most famous landmarks in China...",
      "prepareTime": 15,
      "recordTime": 60,
      "requiresRecording": true
    },
    {
      "step": 4,
      "instruction": "Describe the picture you see.",
      "image": {
        "url": "https://xxx.com/picture.jpg",
        "alt": "A busy street scene"
      },
      "prepareTime": 30,
      "recordTime": 90,
      "requiresRecording": true
    }
  ]
}
```

---

## 五、富文本内容处理方案

对于需要富文本的场景（如数学公式、特殊排版），建议采用以下策略：

### 5.1 轻量富文本：Markdown + 扩展语法

```json
{
  "stem": "计算 $\\frac{1}{2} + \\frac{1}{3}$ 的值",
  "format": "markdown+latex"
}
```

### 5.2 复杂富文本：独立字段存储

```json
{
  "stem": {
    "plain": "计算分数相加的值",
    "richText": "<p>计算 <math>...</math> 的值</p>",
    "format": "html"
  }
}
```

### 5.3 推荐：使用结构化富文本（类似 ProseMirror/Slate）

```json
{
  "stem": {
    "type": "doc",
    "content": [
      {
        "type": "paragraph",
        "content": [
          { "type": "text", "text": "计算 " },
          { "type": "math", "attrs": { "latex": "\\frac{1}{2}" } },
          { "type": "text", "text": " 的值" }
        ]
      }
    ]
  }
}
```

---

## 六、数据库设计建议

### 6.1 表结构

```sql
-- 试卷表
CREATE TABLE papers (
  id VARCHAR(32) PRIMARY KEY,
  title VARCHAR(255),
  subject VARCHAR(50),
  grade VARCHAR(20),
  total_score INT,
  duration INT,           -- 考试时长（秒）
  created_at TIMESTAMP,
  updated_at TIMESTAMP
);

-- 题目表
CREATE TABLE questions (
  id VARCHAR(32) PRIMARY KEY,
  type VARCHAR(50),       -- listening_choice, listening_fill, speaking_steps 等
  content JSON,           -- 完整的 JSON 结构化数据
  difficulty DECIMAL(3,2),
  created_at TIMESTAMP,
  updated_at TIMESTAMP
);

-- 试卷-题目关联表
CREATE TABLE paper_questions (
  paper_id VARCHAR(32),
  question_id VARCHAR(32),
  section VARCHAR(50),    -- 所属大题/部分
  order_num INT,          -- 题目顺序
  score DECIMAL(5,2),     -- 该题分值
  PRIMARY KEY (paper_id, question_id)
);
```

### 6.2 为什么用 JSON 字段存储 content？

1. **灵活性**：不同题型结构差异大，JSON 可以统一存储
2. **查询能力**：MySQL 8.0+ / PostgreSQL 都支持 JSON 路径查询
3. **扩展性**：新增题型无需改表结构

---

## 七、方案对比总结

| 方案 | 开发效率 | 维护成本 | 灵活性 | 适用场景 |
|------|---------|---------|--------|---------|
| **纯 HTML** | 高（初期） | 高 | 低 | 快速原型、导入第三方 |
| **混合模式**（JSON+HTML字段） | 中 | 高 | 中 | 兼容旧系统 |
| **纯 JSON** | 中 | 低 | 高 | **推荐：新系统** |

---

## 八、结论与建议 

### ✅ 推荐方案：纯 JSON 结构化存储

**理由：**

1. **数据与展示分离**
   - 同一份数据可以在 Web、移动端、PDF 导出等场景复用
   - 样式修改不影响数据，数据修改不影响样式

2. **业务逻辑简单**
   - 答案判断：`userAnswer === question.answer`
   - 无需解析 HTML DOM

3. **编辑器友好**
   - 可视化编辑器操作 JSON 结构
   - 每个字段独立编辑，不会互相干扰

4. **便于扩展**
   - 新增题型只需定义新的 JSON Schema
   - 支持版本控制和数据迁移

### ⚠️ 需要额外处理的事项

1. **渲染层**：需要开发 JSON → UI 的渲染组件
2. **导入转换**：第三方 HTML 数据需要转换为 JSON
3. **富文本**：复杂排版需要选择合适的富文本方案

---

## 九、深度辩论：混合模式 vs JSON 模式

> **背景**：团队讨论中有人认为混合模式更好，理由是"取出来直接显示，前端不用解析"。
> 以下是针对这一观点的深度分析和反驳。

### 9.1 "取出来直接显示，前端不用解析" —— 这是假象

**真相：你必须解析，只是把解析藏到了 DOM 操作里**

```
┌─────────────────────────────────────────────────────────────────┐
│  混合模式的"不用解析"是自欺欺人                                    │
├─────────────────────────────────────────────────────────────────┤
│                                                                  │
│  实际开发中你必须：                                                │
│  "解析出来在前面添加上选择图标，然后添加点击事件"                    │
│                                                                  │
│  这不是解析是什么？                                                │
│                                                                  │
│  你必须：                                                         │
│  1. 找到所有选项位置 → querySelectorAll('.qml-op')               │
│  2. 判断是第几个子题 → 解析 DOM 结构                              │
│  3. 获取正确答案 → 解析 answer 字段的 HTML                        │
│  4. 绑定点击事件 → 操作 DOM                                       │
│  5. 显示对错状态 → 操作 DOM                                       │
│                                                                  │
│  你只是把"解析 JSON"换成了"解析 DOM"                              │
│  而 DOM 解析比 JSON 解析复杂 10 倍                                │
│                                                                  │
└─────────────────────────────────────────────────────────────────┘
```

**代码对比：获取第2题的正确答案**

混合模式：
```javascript
// answer 字段: "<div>1. <span class='qml-an'>A</span> 2. <span class='qml-an'>C</span>..."
function getAnswer(answerHtml, questionIndex) {
  const temp = document.createElement('div');
  temp.innerHTML = answerHtml;
  const answers = temp.querySelectorAll('.qml-an');
  return answers[questionIndex]?.textContent?.trim(); // 祈祷结构不变
}
```

JSON 模式：
```javascript
const answer = question.subQuestions[1].answer; // "C"
```

**哪个叫"不用解析"？**

---

### 9.2 "改公共样式类就行" —— CSS 改不了 HTML 结构

**学科网的选项结构是 `<table>`：**

```html
<table class="qml-og">
  <tr>
    <td>A. In the morning.</td>
    <td>B. In the afternoon.</td>
    <td>C. In the evening.</td>
  </tr>
</table>
```

**三端布局需求对比：**

| 端 | 布局需求 | table 能实现吗？ |
|----|---------|---------------|
| PC | 横排 ABC | ✅ 可以 |
| iPad 横屏 | 横排 ABC | ✅ 可以 |
| iPad 竖屏 | 可能要竖排 | ⚠️ 勉强 |
| 手机 | 必须竖排 | ❌ **table 做不到** |

**CSS 能把 `<td>` 变成竖排吗？**

```css
/* 你可以试试 */
.qml-og td {
  display: block; /* td 变块级 */
}
```

结果：布局会乱，因为 `<tr>` 还在。你要连 `<tr>` 一起改，但这会破坏 table 语义，各种边距计算全部失效。

**JSON 模式怎么解决？**

```jsx
// PC/iPad 横屏
<div className="options-row">
  {options.map(opt => <Option key={opt.key} {...opt} />)}
</div>

// 手机/iPad 竖屏
<div className="options-column">
  {options.map(opt => <Option key={opt.key} {...opt} />)}
</div>
```

数据不变，布局随意切换。

---

### 9.3 "改 JS 来修改操作逻辑" —— 这是最大的坑

**场景：需求变更 —— 听力选择题要支持"多选"**

**混合模式：**

```javascript
// 原来的代码
optionEl.addEventListener('click', () => {
  // 清除其他选项的选中状态
  allOptions.forEach(o => o.classList.remove('selected'));
  // 选中当前
  optionEl.classList.add('selected');
});

// 现在要改成多选...
// 1. 怎么知道这道题是多选还是单选？
//    → HTML 里没有这个信息！要额外加字段？加在哪？
// 2. 多选的答案格式是什么？"AC" 还是 ["A","C"]？
//    → answer HTML 解析逻辑全部要重写
// 3. 三端都要改一遍
```

**JSON 模式：**

```json
{
  "type": "listening_choice",
  "multiSelect": true,
  "answer": ["A", "C"]
}
```

```javascript
// 组件逻辑
if (question.multiSelect) {
  // 多选逻辑
  toggleSelection(optionKey);
} else {
  // 单选逻辑
  setSelection(optionKey);
}
```

---

### 9.4 三端真正的挑战

| 差异点 | 混合模式处理方式 | JSON 模式处理方式 |
|--------|---------------|-----------------|
| 布局不同 | 改 CSS（受限于 HTML 结构） | 三端各自渲染组件 |
| 交互不同 | 三端各写 DOM 操作代码 | 共用逻辑层，三端各自 UI |
| 音频播放 | 依赖 `<audio>` 标签 | 封装统一接口，各端实现 |
| 录音功能 | 要往 HTML 里插入录音组件 | 组件化，独立实现 |
| 状态管理 | 状态存在 DOM 里（className） | 状态存在数据层 |

**灵魂拷问：状态存在哪？**

**混合模式**：
- 用户选了什么？→ 看 DOM 哪个有 `.selected` class
- 用户答对了吗？→ 看 DOM 有没有 `.correct` class
- 用户做了几题？→ 遍历 DOM 数一数

**JSON 模式**：
```javascript
const state = {
  answers: {
    "q1": "A",
    "q2": "C",
    "q3": null  // 未作答
  },
  progress: 2 / 3
};
```

当你需要"保存进度"、"断点续答"时，混合模式要把 DOM 状态序列化出来，JSON 模式直接 `JSON.stringify(state)`。

---

### 9.5 真实场景压力测试

#### 场景1：导出试卷 PDF

| 模式 | 实现方式 |
|------|---------|
| 混合模式 | 把 HTML 渲染成 PDF？那些交互按钮、选中状态怎么办？要去掉交互元素？正则替换？ |
| JSON 模式 | 写一个 PDF 渲染器，读 JSON 生成 PDF，数据结构清晰，一目了然 |

#### 场景2：统计"第3题选A的错误率"

**混合模式**：
```sql
-- 怎么查？answer 是 HTML 字符串
-- SELECT * FROM answers WHERE ???
-- 你要在数据库里解析 HTML？
```

**JSON 模式**：
```sql
SELECT
  COUNT(*) FILTER (WHERE content->'answers'->>'q3' = 'A') as chose_A,
  COUNT(*) as total
FROM user_answers
WHERE question_id = 'xxx';
```

#### 场景3：AI 自动批改口语题

| 模式 | 实现方式 |
|------|---------|
| 混合模式 | 把 HTML 发给 AI？AI 返回结果你怎么塞回 HTML？ |
| JSON 模式 | `{ "questionId": "xxx", "userRecording": "https://...", "aiScore": { "pronunciation": 8, "fluency": 7 } }` |

#### 场景4：选项顺序随机打乱

**混合模式**：
```javascript
// 1. 解析 HTML 获取选项
// 2. 打乱顺序
// 3. 重建 HTML
// 4. 答案映射还要改（原来 A 是对的，打乱后可能变成 C）
// 5. 三端都要写一遍这个逻辑
```

**JSON 模式**：
```javascript
const shuffled = shuffle(question.options);
// 答案对应 key 不变，A 还是 A，只是显示位置变了
```

#### 场景5：错题本功能

| 模式 | 存储内容 | 复杂度 |
|------|---------|--------|
| 混合模式 | 存 HTML + 用户选择（怎么关联？）+ 解析逻辑 | 高 |
| JSON 模式 | `{ questionId, userAnswer: "B", correctAnswer: "A" }` | 低 |

---

### 9.6 终极反问清单

在讨论时，可以用以下问题反问支持混合模式的人：

> 1. **如果学科网改了 HTML 结构，你的解析代码全部失效，怎么办？**
>    - 混合模式：改所有解析逻辑 + 测试
>    - JSON模式：写一次转换脚本，数据结构不变

> 2. **如果要支持"题目收藏"功能，用户收藏的是什么？**
>    - 混合模式：存一大段 HTML？还是存 ID 然后重新拉 HTML？
>    - JSON模式：存 question 对象，随时可渲染

> 3. **如果要做"错题本"，展示用户的错误选项和正确答案？**
>    - 混合模式：存 HTML + 用户选择（怎么关联？）+ 解析逻辑
>    - JSON模式：`{ questionId, userAnswer: "B", correctAnswer: "A" }`

> 4. **如果产品说"选项顺序要随机打乱"，你怎么实现？**
>    - 混合模式：解析 HTML → 提取选项 → 打乱 → 重建 HTML（答案映射还要改）
>    - JSON模式：`shuffle(question.options)`，答案对应 key 不变

> 5. **如果要统计"哪道题错误率最高"，你怎么查数据库？**
>    - 混合模式：无法直接查询，需要应用层解析
>    - JSON模式：直接 SQL 聚合查询

---

### 9.7 成本对比总结

```
┌────────────────────────────────────────────────────────────────┐
│                                                                 │
│   混合模式的"优势"是虚假的：                                      │
│                                                                 │
│   ❌ "不用解析" → 其实是把解析从数据层移到 DOM 层，更复杂          │
│   ❌ "改 CSS"   → CSS 改不了 HTML 结构，三端适配受限              │
│   ❌ "改 JS"    → 每次需求变更都要写 DOM 操作，代码与结构强耦合    │
│                                                                 │
│   JSON 模式的优势是真实的：                                       │
│                                                                 │
│   ✅ 数据与展示分离 → 三端共用数据，各自渲染                       │
│   ✅ 结构化清晰     → 答案提取、状态管理、数据查询都简单            │
│   ✅ 扩展性强       → 新增字段、新增题型，不影响现有逻辑            │
│   ✅ 长期维护成本低 → 代码不依赖 HTML 结构，需求变更改动小          │
│                                                                 │
└────────────────────────────────────────────────────────────────┘

┌────────────────────────────────────────────────────────────────┐
│                                                                 │
│   时间成本对比：                                                  │
│                                                                 │
│   混合模式：初期省 1 天，后期每个需求多花 3 天                      │
│   JSON 模式：初期多花 3 天，后期每个需求省 1 天                     │
│                                                                 │
│   这是一个长期项目，不是一次性 demo                                │
│                                                                 │
└────────────────────────────────────────────────────────────────┘
```

---

### 9.8 建议：用实际代码说话

如果讨论无法达成共识，建议进行一次小规模 PK：

**任务**：实现"选项顺序随机打乱"功能

- A 同学用混合模式实现
- B 同学用 JSON 模式实现

比较：
1. 代码行数
2. 可读性
3. 三端复用程度
4. 如果需求变更（比如"只打乱错误选项"），改动量

**用事实说话，比争论更有效。**

---

## 十、待讨论问题

1. **富文本方案选择**：Markdown、HTML子集、还是结构化富文本（Slate/ProseMirror）？
2. **音频存储**：直接存 URL 还是需要额外的媒体资源管理？
3. **版本控制**：题目修改后是否需要保留历史版本？
4. **评分规则**：是否需要支持部分得分？（如选择题选对2个得1分）
5. **题目复用**：同一道题是否可以出现在多份试卷中？如何处理分值差异？

---

*文档创建时间：2025-01-16*
*用途：团队内部技术讨论*
